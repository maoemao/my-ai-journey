# LangGraph快速入门以及底层原理解析



------



### **一、什么是 LangGraph？**

- LangGraph 是由 LangChain 团队推出的、用于构建“**有状态、可持续、可控工作流／智能体（Agent）系统**”的框架。 
- 它的核心在于：不仅仅是“顺序调用模型／工具”，还支持“状态管理”、“流程控制（分支／循环）”、“长期执行”这些在简单链式流程里做不到的东西。 
- 换句话说：如果你用 LangChain 构建的是“从 A → B → C”这样的流程，LangGraph 则能处理“用户可能在 A 后跳到 D，或回到 A，再从 B 跳到 E”“多 Agent 协作”“任务可能暂停、恢复”的复杂场景。 
- 官方描述指出：它是一个“低层级的编排基础设施”，你自己定义状态、节点、边，控制执行、恢复、记录。 



所以当你的应用有这些需求：

- 会话跨很多轮、需要记忆上下文、状态很重要

- 多工具／多步骤、流程里可能有分支、回环、人工审核

- 智能体不是一次调用完就结束，而是“持续运行”“状态化”

  那么 LangGraph 就非常适合。



------



### **二、快速入门示例（Python）**



下面给你一个非常简化的“Hello World”式例子，让你看到结构。

```
from langgraph.graph import StateGraph, MessagesState, START, END

def mock_llm(state: MessagesState):
    return {"messages": state["messages"] + [{"role": "ai", "content": "hello world"}]}

graph = StateGraph(MessagesState)
graph.add_node("mock_llm", mock_llm)
graph.add_edge(START, "mock_llm")
graph.add_edge("mock_llm", END)
graph = graph.compile()

result = graph.invoke({"messages": [{"role": "user", "content": "hi!"}]})
print(result)
```

说明几点：

- MessagesState 是状态类型（这里举例）
- StateGraph 构造流程图：节点、边都明确
- invoke() 是执行入口，传入初始状态数据
- 执行流程：START → mock_llm 节点 → END 



你可以把中间节点替换为模型调用、工具执行、条件判断节点等。

例如：

- 节点 A：分析用户意图 → 更新状态 intent
- 节点 B：根据 intent 调用工具 → 更新状态 tool_result
- 节点 C：判断是否需要人工审核 → 如果是 “人工审核”节点，否则 跳到下一个结果节点



这样就能构建一个带“分支”“回环”的流程。



------



### **三、底层原理解析**

要理解 LangGraph 为什么能做以上这些，你需要掌握以下几个关键设计点：



#### **1. 状态（State）设计**

- 每个图（Graph）都有一个状态对象（比如 TypedDict、pydantic 模型）。
- 所有节点接收当前状态、执行操作后返回一个新的状态或更新后的状态。
- 这种设计让整个流程“可记忆”“可追踪”“可恢复”。



#### **2. 节点（Node）与边（Edge）**

- 节点代表一个“动作”或“步骤”：可以是 LLM 调用、工具执行、判断条件、等待人类输入等。
- 边代表流程跳转：从某一节点进入下一节点。边可以是静态（直接连接）或条件性的（基于状态判断）。
- 这种结构类似于“有向图／状态机”，比传统链式流程更灵活。



#### **3. Durable Execution（持久执行）**

- 框架设计支持“流程暂停”“流程恢复” —— 状态可以写入外部存储、节点执行日志可追踪。 
- 适用于“长时间运行”“跨会话”“异步工具调用”这些场景。



#### **4. 可视化与交互（Human-in-the-loop）**

- 开发者可以在流程图中插入人工审核节点、暂停节点，甚至在节点外部修改状态。
- 与 LangSmith 集成后，可视化各执行步骤、状态变化、节点跳转情况。 



#### **5. 流式／并行支持**

- 虽然基于图结构，但框架也支持“流式输出”“并行分支”执行。
- 状态变更可同步或异步、多个分支节点可以并行执行。



------



### **四、典型使用流程（从初始化到部署）**

1. **定义状态模型**：明确你的流程需要保存哪些字段（如用户输入、历史对话、工具调用结果、任务列表、审核状态等）。
2. **定义节点函数**：每个节点为一个函数，接收状态，执行逻辑（LLM 调用、工具任务、判断跳转、等待人输入），然后返回更新后的状态。
3. **构建图结构**：使用 StateGraph 添加节点、设置边（流程方向／条件判断）。
4. **编译／执行**：graph.compile() → graph.invoke({initial_state})。可选择异步执行、流式输出。
5. **部署 & 监控**：用 LangSmith 或内部日志系统监控节点执行、状态变化、失败恢复。
6. **版本迭代**：当流程变复杂，如新增多 Agent、分支、回环、人工审核，就扩展图结构。



------



### **五、什么时候用 LangGraph？用哪种场景？**

- 用户对话服务需要跨会话记忆、任务跟踪、长期目标管理。

- 多 Agent 协作流程，比如“用户提交工单 → Agent A 解析 → Agent B 检索知识库 → Agent C 汇总结果”并可能在中间暂停人工审核。

- 非线性流程：有分支、迭代、回退、条件判断。

- 长期运行或需要恢复机制（断点续跑）。

  如果场景只是简单“用户输入 → 模型输出”，链式流程（LangChain）就够了。 



------



### **六、对比 LangChain & LangGraph（聚焦于你作为开发者需要知道的差别）**

| **功能维度** | **LangChain**           | **LangGraph**                        |
| ------------ | ----------------------- | ------------------------------------ |
| 流程模式     | 线性／链式（Chain）     | 图式／状态机，多分支／迭代           |
| 状态管理     | 辅助（Memory 模块）     | 核心（State 对象贯穿整个图）         |
| 分支／回路   | 支持有限                | 原生支持，适合复杂控制流             |
| 多 Agent     | 可以但较冗杂            | 设计为多 Agent 或任务协作场景        |
| 学习门槛     | 较低（快速上手）        | 较高（需要理解状态机／图模型）       |
| 典型场景     | 文档问答、RAG、简单聊天 | 虚拟助理、任务流管理、复杂自动化流程 |



------



### **七、实战建议（针对你 “程序员+学大语言模型应用” 的背景）**

- **先练习简单图**：写一个状态 “用户输入 → 模型分析 → 工具调用 → 输出” 的图，熟悉 StateGraph 接口。
- **结合 LangChain 使用**：你已有用 LangChain 的经验（例如 RAG、工具调用），下一步把那些调用作为图中的节点，用 LangGraph 构建流程。
- **重视状态设计**：设计状态对象时考虑到未来扩展，不仅仅是“上一轮输入”，还可能是“用户目标”“任务历史”“工具结果缓存”。
- **日志与监控一定要加**：在开发中启用可视化监控（如 LangSmith），观察节点执行、状态变化，这样调试更快。
- **不要跳太快搞大规模应用**：先做一个 MVP，再逐渐加入分支、回环、协作 Agent。慢慢扩展。
- **部署思考**：状态持久化、异常恢复、并发管理、版本控制都要考虑到（图的复杂性比链式大很多）。



------

